//-----------------------------------------------------------------------------
//	@brief	インクルード
//-----------------------------------------------------------------------------
#include "TitlePlayerObject.h"
#include "SkeletalMeshComponent.h"
#include "MeshComponent.h"
#include "Mesh.h"
#include "Renderer.h"
#include "PlayerObject.h"
#include "TitlePlayerStateBase.h"

/*
@fn コンストラクタ
@param	ポジション
@param	再利用するかフラグ
@param	オブジェクト判別用tag
*/
TitlePlayerObject::TitlePlayerObject(const Vector3& _pos, bool _reUseGameObject, const Tag _objectTag)
	: GameObject(_reUseGameObject, _objectTag)
	, Gravity (400.0f)
	, MaxFallSpeed(-200.0f)
	, JumpDelayTime(120)
	, JumpSpeed(15.0f)
	, JumpLimitTime(13)
	, OnGroundCoordinate(100.0f)
	, RotationAngle(90.0f)
	, JumpAttackRotationAngle(10.0f)
	, FirstJumpPower(40.0f)
{

	// ポジションをセット
	SetPosition(_pos);

	//モデル描画用のコンポーネント
	skeltalMeshComponent = new SkeletalMeshComponent(this);
	//Rendererクラス内のMesh読み込み関数を利用してMes hをセット(.gpmesh)
	skeltalMeshComponent->SetMesh(RENDERER->GetMesh("Assets/Model/Player/PlayerModel/SK_Rob.gpmesh"));
	//Rendererクラス内のSkeletonデータ読み込み関数を利用してSkeletonをセット(.gpskel)
	skeltalMeshComponent->SetSkeleton(RENDERER->GetSkeleton("Assets/Model/Player/PlayerModel/SK_Rob.gpskel"));
	//メッシュ情報取得
	mesh = skeltalMeshComponent->GetMesh();
	// 輝度情報を取得
	luminance = mesh->GetLuminace();

	meshComponent = new MeshComponent(this, false, false);
	meshComponent->SetMesh(RENDERER->GetMesh("Assets/Model/Player/JumpAttackPlayerModel/JumpAttackPlayer.gpmesh"));

	//Rendererクラス内のSkeletonデータ読み込み関数を利用してAnimationをセット(.gpanim)
	//アニメ―ション用の可変長配列をリサイズ
	animTypes.resize(TitlePlayerState::STATE_NUM);
	//アニメーションを読み込み
	animTypes[IDLE] = RENDERER->GetAnimation("Assets/Model/Player/PlayerAnimation/Happy_Idle_Anim.gpanim", true);
	animTypes[RUN] = RENDERER->GetAnimation("Assets/Model/Player/PlayerAnimation/Running.gpanim", true);
	animTypes[JUMPLOOP] = RENDERER->GetAnimation("Assets/Model/Player/PlayerAnimation/Floating.gpanim", true);
	animTypes[JUMPSTART] = RENDERER->GetAnimation("Assets/Model/Player/PlayerAnimation/Jump_up.gpanim", false);
	animTypes[JUMPEND] = RENDERER->GetAnimation("Assets/Model/Player/PlayerAnimation/Landing.gpanim", false);

	//anim変数を速度0.5fで再生
	skeltalMeshComponent->PlayAnimation(animTypes[RUN], 1.0f);

	// メンバー変数初期化
	//firstJumpPower = 40.0f;
	//jumpPower = firstJumpPower;
	jumpCount = 0;
	// 回転処理
	RotationProcess(RotationAngle,Vector3::UnitZ);
}

/*
@fn デストラクタ
@brief  objectの削除を行う
*/
TitlePlayerObject::~TitlePlayerObject()
{
}

/*
@fn アップデート関数
@brief	更新処理を行う
@param	_deltaTime 前のフレームでかかった時間
*/
void TitlePlayerObject::UpdateGameObject(float _deltaTime)
{
	// Rendererにポジションを送る
	RENDERER->SetPlayerPositon(position);

	// アニメーション状態の更新
	AnimationUpdate();


	//ジャンプ中もしくは落下中の時重力をかける（一定数以上かかったら止めて定数にする）
	if (onGround == false && animState != JUMPATTACK)
	{
		GravityProcess(_deltaTime);
	}

	// 接地状態でかつジャンプ中で無かったら
	if (onGround == true && jumpFlag == false)
	{
		JumpDelayProcess();
	}

	// ジャンプ中だったら
	if(jumpFlag == true)
	{
		JumpProcess();
	}

	// ポジションに速度を追加
	position = position + velocity * _deltaTime;
	// ポジションを更新
	SetPosition(position);

	// 接地判定処理
	IsGroundingProcess();

}

/*
@fn 回転処理関数
*/
void TitlePlayerObject::RotationProcess(float _angle, Vector3 _axis)
{
	//Z軸を90度回転させる
	float radian = Math::ToRadians(_angle);
	Quaternion rot = this->GetRotation();
	Quaternion inc(_axis, radian);
	Quaternion target = Quaternion::Concatenate(rot, inc);
	SetRotation(target);
}

/*
@fn 重力処理関数
@param	_deltaTime 前のフレームでかかった時間
*/
void TitlePlayerObject::GravityProcess(float _deltaTime)
{
	// 重力を掛ける
	velocity.z -= Gravity * _deltaTime;

	// 落下速度が規定値を超えていたら
	if (velocity.z <= MaxFallSpeed)
	{
		// 落下速度を規定値に固定する
		velocity.z = MaxFallSpeed;
	}
}

/*
@fn ジャンプディレイ処理関数
*/
void TitlePlayerObject::JumpDelayProcess()
{
	// ジャンプする間隔を数える
	++jumpDelayCount;

	// 時間が来たらジャンプさせジャンプ開始アニメーションを再生
	if (jumpDelayCount >= JumpDelayTime)
	{
		// ジャンプフラグをtrueに
		jumpFlag = true;
		++jumpCount;
		// アニメーション再生
		skeltalMeshComponent->PlayAnimation(animTypes[JUMPSTART], 1.0f);
		// ステータスをJUMPSTARTに変更
		animState = JUMPSTART;
		// カウントリセット
		jumpDelayCount = 0;
	}
}

/*
@fn ジャンプ処理関数
*/
void TitlePlayerObject::JumpProcess()
{
	if (animState == JUMPATTACK)
	{
		jumpAttackRotationAngle += JumpAttackRotationAngle;
		RotationProcess(jumpAttackRotationAngle, Vector3::UnitX);
	}
	else
	{
		// ジャンプ力を追加
		velocity.z = jumpPower;

		// ジャンプ中のカウントを数える
		++jumpFrameCount;

		// ジャンプ中のカウントが規定値以下だったら
		if (jumpFrameCount > 0 && jumpFrameCount < JumpLimitTime)
		{
			// さらにジャンプ力を追加
			jumpPower += JumpSpeed;
		}
		else // ジャンプ中のカウントが規定値以上だったら
		{
			// ジャンプ力を初期に戻す
			jumpPower = firstJumpPower;
			// カウントリセット
			jumpFrameCount = 0;
			// ジャンプフラグをfalseに
			jumpFlag = false;
		}
	}
}

/*
@fn 接地判定処理関数
*/
void TitlePlayerObject::IsGroundingProcess()
{
	// 当たり判定で設置を取っていないので座標で判定
	// 座標が規定値以下だったら
	if (position.z <= OnGroundCoordinate)
	{
		// 接地状態にする
		onGround = true;
		// Z軸の速度を0に初期化
		velocity.z = 0.0f;
	}
	else 	// 座標が規定値以上だったら
	{
		// 接地フラグをfalseに
		onGround = false;
	}
}

/*
@fn アニメーションの更新処理
*/
void TitlePlayerObject::AnimationUpdate()
{
	// 接地中で無かったら
	if (onGround == false)
	{
		// アニメーションの再生が終わっていたら
		if (!skeltalMeshComponent->IsPlaying())
		{
			// ジャンプループアニメーションの再生を開始
			skeltalMeshComponent->PlayAnimation(animTypes[JUMPLOOP], 1.0f);
			// ステータスをJUMPLOOPに変更
			animState = JUMPLOOP;
		}
		
	}

	// ジャンプ中でなくアニメーションステータスがRUNで無かったら
	if (jumpFlag == false && animState != RUN)
	{
		// ランアニメーションの再生を開始
		skeltalMeshComponent->PlayAnimation(animTypes[RUN], 1.0f);
		// ステータスをRUNに変更
		animState = RUN;
		return;
	}

	if (animState == JUMPATTACK)
	{
		skeltalMeshComponent->SetVisible(false);
		meshComponent->SetVisible(true);
	}
	else
	{
		skeltalMeshComponent->SetVisible(true);
		meshComponent->SetVisible(false);
	}
}

const Animation* TitlePlayerObject::GetAnimation(TitlePlayerState _state)
{
	// _state番目のアニメーションを返す
	return animTypes[static_cast<unsigned int>(_state)];
}
